//go:build !windows
// +build !windows

package main

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"sync"
)

// RouteEntry 路由条目
type RouteEntry struct {
	Destination string
	Gateway     string
	Interface   string
	Metric      int
}

// RouteManager 路由管理器
type RouteManager struct {
	installedRoutes []RouteEntry
	originalDNS     []string
	defaultGateway  string
	defaultIface    string
	mutex           sync.Mutex
}

// NewRouteManager 创建路由管理器并自动检测默认网关
func NewRouteManager() (*RouteManager, error) {
	rm := &RouteManager{
		installedRoutes: make([]RouteEntry, 0),
		originalDNS:     make([]string, 0),
	}

	// 检测默认网关和接口
	if err := rm.detectDefaultGateway(); err != nil {
		return nil, fmt.Errorf("检测默认网关失败: %v", err)
	}

	log.Printf("检测到默认网关: %s (接口: %s)", rm.defaultGateway, rm.defaultIface)
	return rm, nil
}

// detectDefaultGateway 检测默认网关
func (rm *RouteManager) detectDefaultGateway() error {
	// 使用 ip route 命令获取默认路由
	cmd := exec.Command("ip", "route", "show", "default")
	output, err := cmd.Output()
	if err != nil {
		return fmt.Errorf("执行ip route命令失败: %v", err)
	}

	// 解析输出，格式如: default via 192.168.1.1 dev eth0
	lines := string(output)
	if lines == "" {
		return fmt.Errorf("未找到默认路由")
	}

	// 更好的解析方式
	parts := make([]string, 0)
	current := ""
	for _, ch := range lines {
		if ch == ' ' || ch == '\t' || ch == '\n' {
			if current != "" {
				parts = append(parts, current)
				current = ""
			}
		} else {
			current += string(ch)
		}
	}
	if current != "" {
		parts = append(parts, current)
	}

	// 查找 via 和 dev 关键字
	for i := 0; i < len(parts); i++ {
		if parts[i] == "via" && i+1 < len(parts) {
			rm.defaultGateway = parts[i+1]
		}
		if parts[i] == "dev" && i+1 < len(parts) {
			rm.defaultIface = parts[i+1]
		}
	}

	if rm.defaultGateway == "" {
		return fmt.Errorf("无法从路由表中解析默认网关")
	}
	if rm.defaultIface == "" {
		return fmt.Errorf("无法从路由表中解析默认接口")
	}

	return nil
}

// AddRoute 添加路由
func (rm *RouteManager) AddRoute(destination, gateway, iface string) error {
	rm.mutex.Lock()
	defer rm.mutex.Unlock()

	// 构建 ip route add 命令
	args := []string{"route", "add", destination}
	if gateway != "" {
		args = append(args, "via", gateway)
	}
	if iface != "" {
		args = append(args, "dev", iface)
	}

	cmd := exec.Command("ip", args...)
	output, err := cmd.CombinedOutput()
	if err != nil {
		// 检查是否是因为路由已存在
		if string(output) != "" && (len(output) > 0) {
			// 路由可能已存在，记录警告但不返回错误
			log.Printf("警告：添加路由可能失败: %s, 输出: %s", destination, string(output))
		} else {
			return fmt.Errorf("添加路由失败: %v, 输出: %s", err, string(output))
		}
	}

	// 记录已安装的路由
	rm.installedRoutes = append(rm.installedRoutes, RouteEntry{
		Destination: destination,
		Gateway:     gateway,
		Interface:   iface,
	})

	log.Printf("已添加路由: %s via %s dev %s", destination, gateway, iface)
	return nil
}

// DeleteRoute 删除路由
func (rm *RouteManager) DeleteRoute(destination string) error {
	rm.mutex.Lock()
	defer rm.mutex.Unlock()

	cmd := exec.Command("ip", "route", "del", destination)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("删除路由失败: %v, 输出: %s", err, string(output))
	}

	log.Printf("已删除路由: %s", destination)
	return nil
}

// CleanupRoutes 清理所有已安装的路由
func (rm *RouteManager) CleanupRoutes() {
	rm.mutex.Lock()
	defer rm.mutex.Unlock()

	for _, route := range rm.installedRoutes {
		output, err := runCmdCombined("ip", "route", "del", route.Destination)
		if err != nil {
			log.Printf("警告：删除路由 %s 失败: %v, 输出: %s", route.Destination, err, string(output))
		} else {
			log.Printf("已清理路由: %s", route.Destination)
		}
	}

	rm.installedRoutes = make([]RouteEntry, 0)
}

// SaveDNS 保存原始DNS配置
func (rm *RouteManager) SaveDNS() error {
	rm.mutex.Lock()
	defer rm.mutex.Unlock()

	// 读取 /etc/resolv.conf
	data, err := os.ReadFile("/etc/resolv.conf")
	if err != nil {
		return fmt.Errorf("读取resolv.conf失败: %v", err)
	}

	// 备份到 /etc/resolv.conf.vpn-backup
	if err := os.WriteFile("/etc/resolv.conf.vpn-backup", data, 0644); err != nil {
		return fmt.Errorf("备份resolv.conf失败: %v", err)
	}

	// 解析DNS服务器
	lines := string(data)
	rm.originalDNS = make([]string, 0)
	for _, line := range splitLines(lines) {
		line = trimSpace(line)
		if len(line) > 10 && line[0:10] == "nameserver" {
			parts := splitBySpace(line)
			if len(parts) >= 2 {
				rm.originalDNS = append(rm.originalDNS, parts[1])
			}
		}
	}

	log.Printf("已保存原始DNS配置: %v", rm.originalDNS)
	return nil
}

// SetDNS 设置DNS服务器
func (rm *RouteManager) SetDNS(dnsServers []string) error {
	rm.mutex.Lock()
	defer rm.mutex.Unlock()

	// 构建新的 resolv.conf 内容
	content := "# Generated by VPN client\n"
	for _, dns := range dnsServers {
		content += fmt.Sprintf("nameserver %s\n", dns)
	}

	// 写入 /etc/resolv.conf
	if err := os.WriteFile("/etc/resolv.conf", []byte(content), 0644); err != nil {
		return fmt.Errorf("写入resolv.conf失败: %v", err)
	}

	log.Printf("已设置DNS服务器: %v", dnsServers)
	return nil
}

// RestoreDNS 恢复原始DNS配置
func (rm *RouteManager) RestoreDNS() error {
	rm.mutex.Lock()
	defer rm.mutex.Unlock()

	// 检查备份文件是否存在
	if _, err := os.Stat("/etc/resolv.conf.vpn-backup"); os.IsNotExist(err) {
		log.Println("没有找到DNS备份文件，跳过恢复")
		return nil
	}

	// 恢复备份
	data, err := os.ReadFile("/etc/resolv.conf.vpn-backup")
	if err != nil {
		return fmt.Errorf("读取DNS备份失败: %v", err)
	}

	if err := os.WriteFile("/etc/resolv.conf", data, 0644); err != nil {
		return fmt.Errorf("恢复DNS配置失败: %v", err)
	}

	// 删除备份文件
	os.Remove("/etc/resolv.conf.vpn-backup")

	log.Println("已恢复原始DNS配置")
	return nil
}

// splitLines 辅助函数：分割字符串为行
func splitLines(s string) []string {
	lines := make([]string, 0)
	current := ""
	for _, ch := range s {
		if ch == '\n' {
			lines = append(lines, current)
			current = ""
		} else {
			current += string(ch)
		}
	}
	if current != "" {
		lines = append(lines, current)
	}
	return lines
}

// trimSpace 辅助函数：去除首尾空格
func trimSpace(s string) string {
	start := 0
	end := len(s)

	for start < end && (s[start] == ' ' || s[start] == '\t') {
		start++
	}
	for end > start && (s[end-1] == ' ' || s[end-1] == '\t' || s[end-1] == '\n' || s[end-1] == '\r') {
		end--
	}

	return s[start:end]
}

// splitBySpace 辅助函数：按空格分割字符串
func splitBySpace(s string) []string {
	parts := make([]string, 0)
	current := ""
	for _, ch := range s {
		if ch == ' ' || ch == '\t' {
			if current != "" {
				parts = append(parts, current)
				current = ""
			}
		} else {
			current += string(ch)
		}
	}
	if current != "" {
		parts = append(parts, current)
	}
	return parts
}
